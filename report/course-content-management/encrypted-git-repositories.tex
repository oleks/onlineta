% vim: set spell:

\section{Encrypted and Signed Git Repositories}

Git comes with a built-in a method to digitally sign tags (versions) and
commits. The intent is to allow us to ensure that particular tags (versions) or
commits come from particular individuals\cite{gerwitz-2013}.

We could use this to ensure that a particular submission indeed comes from a
particular student, but we cannot expect the students to be proficient enough
in Git to use tags and signed commits. Instead, we consider Git repositories
where commits are always, seamlessly signed.

At the core of Git is a key-value store\cite{chacon-2009}. All
version-controlled data, is retained in so-called ``Git objects'', addressed by
the SHA-1 hash of their contents. We ``commit'' data to, and ``checkout'' data
from this data store.

Git retains diffs of files (compared to their earlier versions), rather than
files themselves. A file in a local Git repository is therefore saved twice,
once as a regular file on the file system, and once as a sequence of diffs,
retained as Git objects. When performing a Git push operation to a remote Git
repository, only Git objects are ever sent along.

The \texttt{filter} Git attribute \cite{man-5-gitattributes} allows us to
filter the data before it is committed to, and filter it when it is checked out
of the data store. This is achieved by two commands, ``smudge'' and ``clean'',
respectively. The names imply that the intended use is to retain only ``clean''
data in the data store.

We can abuse the system a bit, taking inspiration from its own
documentation\cite{man-5-gitattributes}. We sign the data on commit and verify
the signature upon checkout. To do this, we append the signature to the data on
commit, and parse out the signature on checkout. We can also specify that a
filter is required, i.e.  must exit with a zero exit code, for a commit or
checkout to succeed. This way, we can fail if we can't verify the signature.

Similarly, we can encrypt the data that goes into the data store, and decrypt
the data when it leaves the data store. This way, we can make sure that student
data stays safe, even if Git objects are ever leaked from our Git server.

\subsection{Keys}

GNU Privacy Guard (GPG) is a suite of cryptographic tools. It supports, among
other things, private/public key cryptography, and boasts tools for trustworthy
distribution of public keys. GnuPG is often used to identify physical
individuals on the Internet. Indeed, the built-in Git tag and commit signing
features expect users to retain a GPG private/public key pair, and securely
distribute their public keys to all interested parties.

OpenSSL is an open-source implementation of the SSL and TLS protocols, used for
secure communication on the Internet. Unlike, GnuPG, OpenSSL is not intended
for the identification of physical individuals. OpenSSL however, is often used
to identify users on servers. For instance, OpenSSL is an underlies OpenSSH,
which we used to identify users on our Git server (see also
\referToSection{openssh}).

Both GnuPG and OpenSSL can be used to implement encrypted and signed Git
repositories. GnuPG however is more conventional for the identification of
individuals, and it is compatible with OpenSSH\cite{man-1-gpg-agent}. OpenSSL
is also very badly documented\footnote{\cite{man-1-openssl} does not even
mention that it can be used to encrypt, decrypt and sign data.} and has
recently suffered a severe drop in popularity due to a major
vulnerability\cite{cvedetails-com-2014c}.

Students can make due with securely informing us of their public GPG key, and
use this to both interact with our Git server, encrypt, and sign their
submissions.

We have not found a way to make public key distribution any more simple for
students, than using some kind of a key server, where keys are validated with
the participation from the teaching staff. One easier approach might be to make
use of their online university accounts and have them supply their keys on
their own in a way similar to Github. We have not had time to look into this.

\subsection{Collaboration}

It is easy enough to encrypt the data for one user, but this defeats many of
the useful collaboration features of Git.

One way in which we can provide for collaborative, encrypted Git repositories
is to encrypt the data for multiple recipients. This is straight-forward using
GPG tools\cite{man-1-gpg2}. The pitfall of this is that new collaborators
cannot see the work done before they joined the project, unless we resort to
rewriting history.

For an implementation of this, see the attached \texttt{./src/git-init.sh}.
