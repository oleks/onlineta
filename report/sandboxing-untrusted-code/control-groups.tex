% vim: set spell:

% TODO: test instance

\section{Control Groups}

Control groups (cgroups) provide a mechanism of hierarchically
grouping/partitioning tasks (see also
\referToAppendix{general-linux-concepts:tasks}) and their future
children\cite{cgroups-cgroups-since-linux-3.14}. On their own, cgroups are
perhaps only useful for simple job tracking. The idea, is to have other
subsystems hook into the cgroups functionality and provide accounting or
limiting of various system resources.

The standard cgroup subsystems include subsystems to monitor and limit memory,
CPU time, I/O, and device activity. Most modern Linux distributions come with
cgroups and many of these canonical subsystems enabled. The system's
\texttt{/proc/config.gz} can reveal the setup on your system\cite{man-5-proc}.
If \texttt{CONFIG\_CGROUPS} is enabled, you have cgroups support.

The variables related to various subsystems are explored further in the
following subsections. First however, we discuss how cgroups can be accessed
and manipulated from user space in general.

\subsection{Managing cgroups}

Cgroups are managed via a pseudo-filesystem: cgroups reside in memory, but can
be manipulated through the virtual file system.  \texttt{cgroup} is therefore
an inherent file system type on systems that have the cgroups functionality
enabled.

\subsubsection{Cgroups, subsystems, and hierarchies}

A cgroup is an association of a set of tasks with a set of preferences for one
or more subsystems.  A hierarchy is a set of cgroups arranged in a tree; every
task in the system is contained in exactly one cgroup of a hierarchy; all
cgroups in a hierarchy, associate their tasks with the same set of preferences.

We say that a hierarchy is ``associated'' with a set of subsystems, and that a
task is ``attached'' to a cgroup.

\subsubsection{Mounting}

When mounting a cgroup file system, we create a new hierarchy. The set of
subsystems to associate with the hierarchy is listed as mount options:

\begin{lstlisting}
$ mount -t cgroup -o cpu,cpuacct cgroup ./cgroup/cpu,cpuacct
\end{lstlisting}

This associates the \texttt{cpu} and \texttt{cpuacct} subsystems with a new
hierarchy, and mounts the hiearchy under the target
\texttt{./cgroup/cpu,cpuacct}, unless one of the subsystems is busy.

A subsystem is busy e.g. if it is associated with a hierarchy having tasks
attached.  Since a hierarchy is automatically attached to all tasks in the
system, this effectively means that a subsystem may be associated with at most
one hierarchy. If a hierarchy assosciated with the exact same set of subsystems
already exists however, it will be reused for the new mount.

What hierarchies already exist, and what subsystems they are associated with,
depends on the system at hand. The system's \texttt{/proc/mounts} can reveal
how this is setup on your system\cite{man-5-proc}.

\subsubsection{Control files and child groups}

After a hierarchy is successfully mounted, we see a range of files, and perhaps
folders, below our target. We refer to these as control files and child groups,
respecitvely.

We monitor/modify the preferences of a cgroup by monitoring/modifying control
files. We create/remove child groups by creating/removing subdirectories below
our target.

With a few exceptions at the root of the hierarchy, all cgroups contain the
same files, created when the cgrpup is created. Some files are common to all
hierarchies, others are due to the associated subsystems. Two common files are
of particular interest:

\begin{description}[\setleftmargin{0.2in}\breaklabel\setlabelstyle{\tt}]

\item [cgroup.procs] Lists the set of thread group IDs in the current cgroup.
Appending a thread group ID to this file moves all the threads in the thread
group into this cgroup.

\item [tasks] Lists the set of thread IDs in the current cgroup. Appending a
thread ID to this file moves the thread into this cgroup.

\end{description}

\subsubsection{Hierarchical accounting}

Hierarchical accounting is when resource accounting is child group aware. All
resource usage is summed up for all tasks in the cgroup, and recursively
for all child groups. Limits are then emposed on the entire hierarchy. A
subsystem does not necessarily perform hierarchical accounting.

\subsection{The Resource Counter}

\label{section:cgroups:resource-counter}

The resource counter is a framework for managing a resource when using control
groups.  The internal data structures aside, the framework makes
recommendations wrt. the control files. A couple of the recommended control
files are of interest to us:

\begin{description}[\setleftmargin{0.2in}\breaklabel\setlabelstyle{\tt}]

\item[<resource>.max\_usage\_in\_<unit\_of\_measurement>] Reading this file, we
get the maximal usage of the resource over time, in the given units. Writing to
this file, resets the value to the current usage of the resource. (The data
written is ignored.)

\item[<resource>.limit\_in\_<unit\_of\_measurement>] Reading this file, we get
the maximal allowed usage of the resource, in the given units. Writing to this
file resets the limit to the given value. A special value may indicate no
limit.

\end{description}

These files are of interest to us as they allow us to probe the usage of a
resource in a test instance and set up resource limits for students or staff.

\subsection{memory}

This subsystem allows us to monitor and limit the memory usage of the tasks in
a cgroup. This includes both user and kernel memory and swap
usage\cite{documentation-cgroups-memory.txt}.

Due to the considerable overhead of memory and swap accounting, some
distributions do not enable this cgroup, or merely do not enable swap
accounting by default. The latter is especially misleading. If swapping is
enabled, a memory limit with no swap limit has at best a hapless effect.

You can check the setup on your system by checking the options prefixed with
\texttt{CONFIG\_MEMCG\_} in your \texttt{/proc/config.gz}. Swap accounting can
be enabled using the standard kernel parameter
\texttt{swapaccount=1}\cite{documentation-kernel-parameters.txt}. Enabling the
memory cgroup can be a little more distribution-specific.  In a Debian
kernel, this can be done using the kernel parameter
\texttt{cgroup\_enable=memory}\cite{hutchings-2011}.

The memory subsystem uses a resource counter for a couple different memory
resources. The resource counter control files (see also
\referToSection{cgroups:resource-counter}) are prefixed as follows:

\begin{description}[\setleftmargin{0.2in}\breaklabel\setlabelstyle{\tt}]

\item[memory]

The main memory counter. This includes both user and kernel memory.

\item[memory.memsw]

The main memory, plus swap. Limiting this value to the same value as the main
memory controller, disables swap.

\item[memory.kmem]

Kernel memory. All kernel memory is also accounted for by the main memory
counter. It is not necessary to limit this value if swapping is disabled and
there is a limit on the main memory counter (since kernel memory cannot be
swapped out).

\item[memory.kmem.tcp]

Kernel TCP buffer memory. Although we will disallow networking in general, it
might be a good idea to 0-limit this resource as an extra precaution.

\end{description}

The limits and usage are always measured in bytes.

Writing \texttt{-1} to \texttt{<resource>.limit\_in\_bytes} for any resource,
removes the limit on the resource.

The memory subsystem does not necessarily perform hierarchical accounting. This
is enabled by writing \texttt{1} to the control file \texttt{use\_hierarchy} in
the root cgroup.

\subsection{cpuacct}

The CPU accounting (cpuacct) subsystem allows us to monitor the CPU time usage
of the tasks in a cgroup. The cpuacct subsystem always performs hierarchical
accounting\cite{documentation-cgroups-cpuacct.txt}.

The cpuacct subsystem provides a couple control files of interest:

\begin{description}[\setleftmargin{0.2in}\breaklabel\setlabelstyle{\tt}]

\item[cpuacct.usage] Shows the total CPU time spent by the cgroup, in
nanoseconds.

\item[cpuacct.usage\_percpu] Similar to \texttt{cpuacct.usage}, but shows the
CPU time spent on each CPU core.

\item[cpuacct.stat] Shows a further division of the CPU time spent: showing how
much of the CPU time was spent running in user mode, and how much in kernel
mode, using the \texttt{USER\_HZ} time unit.

\end{description}

\subsection{cpu}

\subsection{cpuset}

\subsection{devices}

\subsection{blkio}
