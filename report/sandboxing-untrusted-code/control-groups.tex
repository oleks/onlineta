% vim: set spell:

\section{Control Groups}

Control groups (cgroups) provide a mechanism of hierarchically
grouping/partitioning tasks (see also
\referToAppendix{general-linux-concepts:tasks}) and their future
children\cite{cgroups-cgroups-since-linux-3.14}. On their own, cgroups are
perhaps only useful for simple job tracking. The idea, is to have other
subsystems hook into the cgroups functionality and provide accounting or
limiting of various system resources.

The standard cgroup subsystems include subsystems to monitor and limit memory,
CPU time, I/O, and device activity. Most modern Linux distributions come with
control groups and many of these canonical subsystems enabled. The system's
\texttt{/proc/config.gz} can reveal the setup on your system\cite{man-5-proc}.
If \texttt{CONFIG\_CGROUPS} is enabled, you have cgroups support.

The variables related to various subsystems are explored further in the
following subsections. First however, we discuss how cgroups can be accessed
and manipulated from user space in general.

\subsection{Managing cgroups}

Cgroups are managed via a pseudo-filesystem: cgroups reside in memory, but can
be manipulated through the virtual file system.  \texttt{cgroup} is therefore
an inherent file system type on systems that have the cgroups functionality
enabled.

\subsubsection{Cgroups, subsystems, and hierarchies}

A cgroup is an association of a set of tasks with a set of preferences for one
or more subsystems.  A hierarchy is a set of cgroups arranged in a tree; every
task in the system is contained in exactly one cgroup of a hierarchy; all
cgroups in a hierarchy, associate their tasks with the same set of preferences.

We say that a hierarchy is ``associated'' with a set of subsystems, and that a
task is ``attached'' to a cgroup.

\subsubsection{Mounting}

When mounting a cgroup file system, we create a new hierarchy. The set of
subsystems to associate with the hierarchy is listed as mount options:

\begin{lstlisting}
$ mount -t cgroup -o cpu,cpuacct cgroup ./cgroup/cpu,cpuacct
\end{lstlisting}

This associates the \texttt{cpu} and \texttt{cpuacct} subsystems with a new
hierarchy, and mounts the hiearchy under the target
\texttt{./cgroup/cpu,cpuacct}, unless one of the subsystems is busy.

A subsystem is busy e.g. if it is associated with a hierarchy having tasks
attached.  Since a hierarchy is automatically attached to all tasks in the
system, this effectively means that a subsystem may be associated with at most
one hierarchy. If a hierarchy assosciated with the exact same set of subsystems
already exists however, it will be reused for the new mount.

What hierarchies already exist, and what subsystems they are associated with,
depends on the system at hand. The system's \texttt{/proc/mounts} can reveal
how this is setup on your system\cite{man-5-proc}.

\subsubsection{Tasks and nested cgroups}

After a hierarchy is successfully mounted, we see a range of files, and perhaps
folders, below our target. We monitor/modify the preferences of a cgroup by
monitoring/modifying these files. We create/remove child cgroups by
creating/removing subdirectories.

With a few exception at the root of the hierarchy, all cgroups contain the same
files, created when the cgrpup is created. Some files are common to all
hierarchies, others are due to the associated subsystems. Two files are of
particular interest:

\begin{description}[\setleftmargin{0.2in}\breaklabel\setlabelstyle{\tt}]

\item [cgroup.procs] Lists the set of thread group IDs in the current cgroup.
Appending a thread group ID to this file moves all the threads in the thread
group into this cgroup.

\item [tasks] Lists the set of thread IDs in the current cgroup. Appending a
thread ID to this file moves the thread into this cgroup.

\end{description}

\subsection{memory}

\subsection{cpuacct}

\subsection{cpu}

\subsection{cpuset}

\subsection{devices}

\subsection{blkio}
